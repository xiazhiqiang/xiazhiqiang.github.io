---
layout:     post
title:      Java面向对象
subtitle:   Java面向对象基础
date:       2018-06-23
author:     Zhiqiang
header-img: img/post-bg/post-bg-java-study.png
catalog: true
tags:
    - Java
    - 面向对象
    - 2018
---

## 类的定义

```
public class Person {
    String name;
    int age;
    
    // 显式声明构造函数
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void echoName() {
        System.out.println("我的名字是：" + this.name);
    }
    
    public static void main(String arg[]){
        // 创建对象时传递的参数要与构造方法参数列表对应
        Person my = new Person("Zhiqiang", 22);
    }
}
```

- 在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。
- 构造方法可以在类实例化的过程中做一些初始化的工作。
- 构造方法的名称必须与类的名称相同，并且没有返回值。
- 每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。

## 创建对象

对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。

在Java中，使用new关键字来创建对象，一般有以下三个步骤：

- 声明：声明一个对象，包括对象名称和对象类型。
- 实例化：使用关键字new来创建一个对象。
- 初始化：使用new创建对象时，会调用构造方法初始化对象。

```
# 声明一个对象
Person my;

# 实例化
my = new Person("诚沐", 22);

# 直接实例化
Person p1 = new Person("Lucy", 21);
```
## 访问修饰符

访问修饰符也叫访问控制符，是指能够控制类、成员变量、方法的使用权限的关键字。

<table>
  <thead>
    <tr>
      <th>修饰符</th>
      <th>解释</th>
      <th>用法说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>public</td>
      <td>共有的，对所有类可见。公有方法和变量都能被其子类继承。</td>
      <td>修饰类、方法、构造方法和接口</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>受保护的，对同一包内的类和不同包所有子类可见。</td>
      <td>修饰变量、方法和构造方法，不能修饰类和接口</td>
    </tr>
    <tr>
      <td>private</td>
      <td>私有的，在同一类内可见。</td>
      <td>修饰方法、变量和构造方法</td>
    </tr>
    <tr>
      <td>默认的</td>
      <td>在同一包内可见。默认不使用任何修饰符。</td>
      <td>接口里的变量都隐式声明为public static final，接口里的方法默认情况下访问权限为public</td>
    </tr>
  </tbody>
</table>

### 访问控制继承规则

- 父类中声明为public的方法在子类中也必须为public。
- 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。
- 父类中默认修饰符声明的方法，能够在子类中声明为private。
- 父类中声明为private的方法，不能够被继承。

## 变量作用域

在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。

- 类级变量又称全局级变量或静态变量，需要使用static关键字修饰，在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。
- 对象实例级变量就是成员变量，实例化后才会分配内存空间，才能访问。
- 方法级变量就是在方法内部定义的变量，就是局部变量。
- 块级变量就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码

## this关键字

this 关键字用来表示当前对象本身，或当前类的一个实例，通过 this 可以调用本对象的所有方法和属性

## 方法重载

在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为方法重载。

参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。

方法重载的机制：

`方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。`

说明：
- 参数列表不同包括：个数不同、类型不同和顺序不同。
- 仅仅参数变量名称不同是不可以的。
- 跟成员方法一样，构造方法也可以重载。
- 声明为final的方法不能被重载。
- 声明为static的方法不能被重载，但是能够被再次声明。

方法的重载的规则：
- 方法名称必须相同。
- 参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。
- 方法的返回类型可以相同也可以不相同。
- 仅仅返回类型不同不足以成为方法的重载。

## 包装类，拆箱和装箱

包装类：为基本数据类型提供复杂Object类型

每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。

<table>
  <caption>基本数据类型及对应的包装类</caption>
  <tbody>
    <tr>
      <th>基本数据类型</th>
      <th>对应的包装类</th>
    </tr>
    <tr>
      <td>byte</td>
      <td>Byte</td>
    </tr>
    <tr>
      <td>short</td>
      <td>Short</td>
    </tr>
    <tr>
      <td>int</td>
      <td>Integer</td>
    </tr>
    <tr>
      <td>long</td>
      <td>Long</td>
    </tr>
    <tr>
      <td>char</td>
      <td>Character</td>
    </tr>
    <tr>
      <td>float</td>
      <td>Float</td>
    </tr>
    <tr>
      <td>double</td>
      <td>Double</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>Boolean</td>
    </tr>
  </tbody>
</table>

基本类型和对应的包装类可以相互装换：
- 由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；
- 包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。

拆箱和装箱示例：

```
int num = 5;
Integer obj = new Integer(num);// 手动装箱
int num2 = obj.intValue();// 手动拆箱

Integer obj1 = num;  // 自动装箱
int n = obj1;  // 自动拆箱
```

`Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。`

## Java包

在Java中，为了组织代码的方便，可以将功能相似的类放到一个文件夹内，这个文件夹，就叫做包。

包不但可以包含类，还可以包含接口和其他的包。

包以"."来表示层级关系，例如 p1.p2.Test 表示的目录为 /p1/p2/Test.class

package 关键字可以声明一个包，例如：
```
package p1.p2;
```
必须将 package 语句放在所有语句的前面

### 调用包中的类

- 在每个类名前面加上完整的包名
- import语句引入包中的类，import java.util.*

## 继承

- 继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。
- 继承可以理解为一个类从另一个类获取方法和属性的过程。如果类B继承于类A，那么B就拥有A的方法和属性。
- 继承使用 extends 关键字。

`单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。`

## super关键字

super 可以用在子类中，通过点号(.)来获取父类的成员变量和方法。super 也可以用在子类的子类中，Java 能自动向上层类追溯。
  
父类行为被调用，就好象该行为是本类的行为一样，而且调用行为不必发生在父类中，它能自动向上层类追溯。

super 关键字的功能：
- 调用父类中声明为 private 的变量。
- 获取已经覆盖了的方法。
- 作为方法名表示父类构造方法。

`注意：super 与 this 的区别：super 不是一个对象的引用，不能将 super 赋值给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。`

### 继承中方法的覆盖和重载

如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做覆盖旧方法。

被覆盖的方法在子类中只能通过super调用。

`注意：覆盖不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。`

方法覆盖的原则：
- 覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。
- 覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。
- 覆盖方法不能比原方法抛出更多的异常。
- 被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。
- 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。
- 被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。

覆盖和重载的不同：
- 方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。
- 方法覆盖要求返回类型必须一致，方法重载对此没有要求。
- 方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。
- 方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。
- 父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次。

## 多态

有如下类：Animal、Cat 和 Dog，Cat 和 Dog 类都继承自 Animal 类。

变量 obj 的类型为 Animal，它既可以指向 Animal 类的实例，也可以指向 Cat 和 Dog 类的实例

obj 既可以是人类，也可以是猫、狗，它有不同的表现形式，这就被称为多态。多态是指一个事物有不同的表现形式或形态。

```
public class Demo {
    public static void main(String[] args){
        Animal obj = new Animal();
        obj.cry();
        obj = new Cat();
        obj.cry();
        obj = new Dog();
        obj.cry();
    }
}
class Animal{
    // 动物的叫声
    public void cry(){
        System.out.println("不知道怎么叫");
    }
   
}
class Cat extends Animal{
    // 猫的叫声
    public void cry(){
        System.out.println("喵喵~");
    }
}
class Dog extends Animal{
    // 狗的叫声
    public void cry(){
        System.out.println("汪汪~");
    }
}
```

`多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。`

多态性带来了一个问题，就是如何判断一个变量所实际引用的对象的类型

instanceof 运算符用来判断一个变量所引用的对象的实际类型，注意是它引用的对象的类型，不是变量的类型。

如果变量引用的是当前类或它的子类的实例，instanceof 返回 true，否则返回 false。

## 静态变量和静态方法

静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。

静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。

类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。

----

静态方法是一种不能向对象实施操作的方法。

因为静态方法不能操作对象，所以不能在静态方法中访问实例变量，只能访问自身类的静态变量。

使用静态方法的场景：
- 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供
- 一个方法只需要访问类的静态变量

----

总结：

- 一个类的静态方法只能访问静态变量；
- 一个类的静态方法不能够直接调用非静态方法；
- 如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但是不被推荐；
- 静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；
- 静态方法不能被非静态方法覆盖；
- 构造方法不允许声明为 static 的；
- 局部变量不能使用static修饰。

### 静态初始器（静态块）

静态初始器(Static Initializer)是一个存在于类中、方法外面的静态块。静态初始器仅仅在类装载的时候（第一次使用类的时候）执行一次，往往用来初始化静态变量。

### 静态导入

静态导入是 Java 5 的新增特性，用来导入类的静态变量和静态方法
```
import packageName.className;  // 导入某个特定的类
import packageName.*;  // 导入包中的所有类
import static packageName.className.methonName;  // 导入某个特定的静态方法
import static packageName.className.*;  // 导入类中的所有静态成员
```

## final关键字，阻止继承和多态

在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：
- final 修饰的类不能被继承。
- final 修饰的方法不能被子类重写。
- final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。
- final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。
- final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。

final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用。

## 类与类之间的关系

类与类之间最常见的关系主要有三种：依赖(uses-a)、聚合(has-a)和继承(is-a)。

### 依赖

订单类(order)需要访问用户账户类(account)，所以在订单类中需要引用账户类，即订单类依赖账户类。如果修改账户类，会影响到订单类。

依赖的实质就是类中的方法可以操作另一个类的实例。在实际程序设计中，建议尽量减少相互依赖类的数量。

### 聚合

聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，

### 继承

继承就是一个类能调用另一个类的所有数据成员，并在当前类中不需要再重新定义。

> 更多请看<a href="https://blog.csdn.net/K346K346/article/details/59582926" target="_blank">UML类关系——依赖、关联、聚合、组合、泛化</a>

## 抽象 abstract

在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。

这种只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。

使用 abstract 修饰符来表示抽象方法和抽象类。

抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。

```
// 定义一个抽象类
abstract class People{
    private String name;  // 实例变量
   
    // 共有的 setter 和 getter 方法
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
   
    // 抽象方法
    public abstract void work();
}

class Teacher extends People{
    // 必须实现该方法
    public void work(){
        out.println("我的名字叫" + this.getName() + "，我正在讲课，请大家不要东张西望...");
    }
}
```

`注：抽象类只能通过 extends 继承，不能被实例化，不能被实例化，不能被实例化`

## 接口 interface

在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。

一个接口不实现另一个接口，但可以继承多个其他接口。

如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。

```
public interface SataHdd{
    //连接线的数量
    public static final int CONNECT_LINE=4;
    //写数据
    public void writeData(String data);
    //读数据
    public String readData();
}
```

`注意：接口中声明的成员变量默认都是 public static final 的，必须显示的初始化。`

----

在接口和抽象类的选择上，必须遵守这样一个原则：
- 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。
- 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。

## 泛型

```
public class Demo {
    public static void main(String[] args){
        // 实例化泛型类
        Point<Integer, Integer> p1 = new Point<Integer, Integer>();
        p1.setX(10);
        p1.setY(20);
        int x = p1.getX();
        int y = p1.getY();
        System.out.println("This point is：" + x + ", " + y);
       
        Point<Double, String> p2 = new Point<Double, String>();
        p2.setX(25.4);
        p2.setY("东京180度");
        double m = p2.getX();
        String n = p2.getY();
        System.out.println("This point is：" + m + ", " + n);
    }
}

// 定义泛型类
class Point<T1, T2>{
    T1 x;
    T2 y;
    public T1 getX() {
        return x;
    }
    public void setX(T1 x) {
        this.x = x;
    }
    public T2 getY() {
        return y;
    }
    public void setY(T2 y) {
        this.y = y;
    }
}
```

运行结果：
This point is：10, 20
This point is：25.4, 东京180度

与普通类的定义相比，上面的代码在类名后面多出了 <T1, T2>，T1, T2 是自定义的标识符，也是参数，用来传递数据的类型，而不是数据的值，我们称之为类型参数。在泛型中，不但数据的值可以通过参数传递，数据的类型也可以通过参数传递。T1, T2 只是数据类型的占位符，运行时会被替换为真正的数据类型。

传值参数（我们通常所说的参数）由小括号包围，如 (int x, double y)，类型参数（泛型参数）由尖括号包围，多个参数由逗号分隔，如 <T> 或 <T, E>。

